from ryu.base import app_manager
from ryu.ofproto import ofproto_v1_3, nicira_ext
from ryu.controller.handler import MAIN_DISPATCHER, set_ev_cls
from ryu.controller import ofp_event
from ryu.topology import event
from ryu.lib import addrconv
from ryu.lib.packet import packet, icmpv6
from ryu.app.wsgi import WSGIApplication
from DCnetSrvRestAPIManager import DCnetSrvRestAPIManager
import array

class   DCnetSrvController (app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]
    _CONTEXTS = {'wsgi' : WSGIApplication}

    def __init__(self, *args, **kwargs):
        super(DCnetSrvController, self).__init__(*args, **kwargs)

        self.server_names = ["dcnet-srv000", "dcnet-srv001", "dcnet-srv010", "dcnet-srv011", "dcnet-srv100", "dcnet-srv101", "dcnet-srv110", "dcnet-srv111"]
        self.switch_connected = 0

        self.vms = {}

        self.next_ofport = 3
        self.qmpport = 18000
	self.incport = 19000

	wsgi = kwargs['wsgi']
	wsgi.register(DCnetSrvRestAPIManager, {'controller' : self})

    @set_ev_cls (event.EventSwitchEnter, MAIN_DISPATCHER)
    def handle_switch_enter (self, ev):

        if self.switch_connected == 1:
            return

        switch = ev.switch
        dpid = switch.dp.id

        if dpid > len(self.server_names):
            return

        self.switch = switch
        name = self.server_names[dpid-1]
        print "Server: {0}".format(name)
        self.srvname = name
        self.uid = self.server_names.index(self.srvname)
        print 'Server UID is {0}'.format(self.uid)

        dp = switch.dp
        ofp = dp.ofproto
        parser = dp.ofproto_parser

        # Add a flow rule to handle packets coming in on phisical NIC
        # The eth_dst must be an RMAC and we must restore the UID-MAC
        # from the destination IPv6 address
        match = parser.OFPMatch(in_port=1,
                                eth_dst=('dc:dc:dc:00:00:00','ff:ff:ff:00:00:00'),
                                eth_type=0x86dd)
        action1 = parser.NXActionRegMove(src_field="ipv6_dst_nxm",
                                         dst_field="eth_dst_nxm",
                                         n_bits=48,
                                         src_ofs=0,
                                         dst_ofs=0)
        action2 = parser.NXActionResubmitTable(table_id=0)
        instr = parser.OFPInstructionActions(ofp.OFPIT_APPLY_ACTIONS, [action1, action2])
        flowmod = parser.OFPFlowMod(datapath=dp,
                                    table_id=0,
                                    priority=1000,
                                    match=match,
                                    instructions=[instr])
        dp.send_msg(flowmod)

        # Add a flow rule for packets leaving the server
        # eth_dst must be a UID-MAC
        match = parser.OFPMatch(eth_dst=('98:98:98:00:00:00','ff:ff:ff:00:00:00'))
        action = parser.OFPActionOutput(1)
        instr = parser.OFPInstructionActions(ofp.OFPIT_APPLY_ACTIONS, [action])
        flowmod = parser.OFPFlowMod(datapath=dp,
                                    table_id=0,
                                    priority=500,
                                    match=match,
                                    instructions=[instr])
        dp.send_msg(flowmod)

        # Add a flow rule for connectivity to the hypervisor interface
        match = parser.OFPMatch(eth_dst='98:98:98:00:00:{0:02x}'.format(self.uid))
        action = parser.OFPActionOutput(2)
        instr = parser.OFPInstructionActions(ofp.OFPIT_APPLY_ACTIONS, [action])
        flowmod = parser.OFPFlowMod(datapath=dp,
                                    table_id=0,
                                    priority=1000,
                                    match=match,
                                    instructions=[instr])
        dp.send_msg(flowmod)

        # Add a flow rule for DHCP requests generated by VMs (only for network booting)
        match = parser.OFPMatch(eth_type=0x0800,
                                ip_proto=17,
                                udp_src=68,
                                udp_dst=67)
        action = parser.OFPActionOutput(2)
        instr = parser.OFPInstructionActions(ofp.OFPIT_APPLY_ACTIONS, [action])
        flowmod = parser.OFPFlowMod(datapath=dp,
                                    table_id=0,
                                    priority=1000,
                                    match=match,
                                    instructions=[instr])
        dp.send_msg(flowmod)

        """
        # Add a flow rule to handle ARP requests generated by VMs (only for network booting)
        match = parser.OFPMatch(eth_type=0x0806)
        action = parser.OFPActionOutput(2)
        instr = parser.OFPInstructionActions(ofp.OFPIT_APPLY_ACTIONS, [action])
        flowmod = parser.OFPFlowMod(datapath=dp,
                                    table_id=0,
                                    priority=500,
                                    match=match,
                                    instructions=[instr])
        dp.send_msg(flowmod)
        """

        # Add a rule to handle Neighbor Solicitations generated by VMs
        match = parser.OFPMatch(eth_type=0x86dd,
                                ip_proto=58,
                                icmpv6_type=135)
        action = parser.OFPActionOutput(ofp.OFPP_CONTROLLER)
        instr = parser.OFPInstructionActions(ofp.OFPIT_APPLY_ACTIONS, [action])
        flowmod = parser.OFPFlowMod(datapath=dp,
                                    table_id=0,
                                    priority=1000,
                                    match=match,
                                    instructions=[instr])
        dp.send_msg(flowmod)

    # Add flow rules for newly created VM
    def create_vm (self, mac, port):

        dp = self.switch.dp
        ofp = dp.ofproto
        parser = dp.ofproto_parser

        match = parser.OFPMatch(eth_dst=mac)
        action = parser.OFPActionOutput(port)
        instr = parser.OFPInstructionActions(ofp.OFPIT_APPLY_ACTIONS, [action])
        flowmod = parser.OFPFlowMod(datapath=dp,
                                    table_id=0,
                                    priority=1000,
                                    match=match,
                                    instructions=[instr])
        dp.send_msg(flowmod)

    # Remove rules related to a VM
    def delete_vm (self, mac, port):

        dp = self.switch.dp
        ofp = dp.ofproto
        parser = dp.ofproto_parser

        match = parser.OFPMatch(eth_dst=mac)
        flowmod = parser.OFPFlowMod(datapath=dp,
                                    table_id=0,
                                    match=match,
                                    out_port=ofp.OFPP_ANY,
                                    out_group=ofp.OFPG_ANY,
                                    command=ofp.OFPFC_DELETE)
        dp.send_msg(flowmod)

    # Handle incoming NS messages
    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def packet_in_handler (self, ev):

        msg = ev.msg
        dp = msg.datapath
        pkt = packet.Packet(array.array('B', msg.data))
        ofp = dp.ofproto
        parser = dp.ofproto_parser

        eth = None
        ip = None
        icmp = None

        # Extract protocols from the packet
        try:
            for p in pkt.protocols:
                if p.protocol_name == 'ethernet':
                    eth = p
                elif p.protocol_name == 'ipv6':
                    ip = p
                elif p.protocol_name == 'icmpv6':
                    if p.type_ == 135 and p.data != None and p.data.option != None:
                        icmp = p
                        nd = icmp.data
        except:
            pass

        # If the packet is not a NS message, return
        if eth == None or ip == None or icmp == None:
            return

        # Derive the MAC address based on ND target
        tgt = array.array('B', addrconv.ipv6.text_to_bin(nd.dst))
        mac = addrconv.mac.bin_to_text((tgt[10:]).tostring())

        print 'Incoming NS for {0}, MAC: {1}'.format(nd.dst, mac)

        # Modify the packet to form the NA message
        eth.dst = eth.src
        eth.src = mac
        ip.dst = ip.src
        ip.src = nd.dst
        ip.hop_limit = 255
        icmp.type_ = 136
        icmp.csum = 0
        nd.res = 2
        nd.option = icmpv6.nd_option_tla(length=1, hw_src=mac, data=None)

        action = parser.NXActionResubmitTable(table_id=0)
        packet_out = parser.OFPPacketOut(datapath=dp,
                                         buffer_id=ofp.OFP_NO_BUFFER,
                                         in_port=ofp.OFPP_CONTROLLER,
                                         actions=[action],
                                         data=pkt)
        dp.send_msg(packet_out)
